// Code generated by Stan version 2.14.0

#include <stan/model/model_header.hpp>

namespace odePlatelets_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
Balances(const T0__& t,
             const std::vector<T1__>& x,
             const std::vector<T2__>& theta,
             const std::vector<T3__>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
            validate_non_negative_index("dxdt", "11", 11);
            vector<fun_scalar_t__> dxdt(11);
            stan::math::initialize(dxdt, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(dxdt,DUMMY_VAR__);
            validate_non_negative_index("dxdt_total", "11", 11);
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  dxdt_total(static_cast<Eigen::VectorXd::Index>(11));
            (void) dxdt_total;  // dummy to suppress unused var warning

            stan::math::initialize(dxdt_total, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(dxdt_total,DUMMY_VAR__);
            validate_non_negative_index("control_vector", "7", 7);
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  control_vector(static_cast<Eigen::VectorXd::Index>(7));
            (void) control_vector;  // dummy to suppress unused var warning

            stan::math::initialize(control_vector, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(control_vector,DUMMY_VAR__);
            validate_non_negative_index("rate_vector", "7", 7);
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  rate_vector(static_cast<Eigen::VectorXd::Index>(7));
            (void) rate_vector;  // dummy to suppress unused var warning

            stan::math::initialize(rate_vector, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rate_vector,DUMMY_VAR__);
            validate_non_negative_index("modified_rate_vector", "11", 11);
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  modified_rate_vector(static_cast<Eigen::VectorXd::Index>(11));
            (void) modified_rate_vector;  // dummy to suppress unused var warning

            stan::math::initialize(modified_rate_vector, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(modified_rate_vector,DUMMY_VAR__);
            fun_scalar_t__ FII;
            (void) FII;  // dummy to suppress unused var warning

            stan::math::initialize(FII, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(FII,DUMMY_VAR__);
            stan::math::assign(FII,get_base1(x,1,"x",1));
            fun_scalar_t__ FIIa;
            (void) FIIa;  // dummy to suppress unused var warning

            stan::math::initialize(FIIa, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(FIIa,DUMMY_VAR__);
            stan::math::assign(FIIa,get_base1(x,2,"x",1));
            fun_scalar_t__ PC;
            (void) PC;  // dummy to suppress unused var warning

            stan::math::initialize(PC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(PC,DUMMY_VAR__);
            stan::math::assign(PC,get_base1(x,3,"x",1));
            fun_scalar_t__ APC;
            (void) APC;  // dummy to suppress unused var warning

            stan::math::initialize(APC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(APC,DUMMY_VAR__);
            stan::math::assign(APC,get_base1(x,4,"x",1));
            fun_scalar_t__ ATIII;
            (void) ATIII;  // dummy to suppress unused var warning

            stan::math::initialize(ATIII, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ATIII,DUMMY_VAR__);
            stan::math::assign(ATIII,get_base1(x,5,"x",1));
            fun_scalar_t__ TM;
            (void) TM;  // dummy to suppress unused var warning

            stan::math::initialize(TM, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(TM,DUMMY_VAR__);
            stan::math::assign(TM,get_base1(x,6,"x",1));
            fun_scalar_t__ TRIGGER;
            (void) TRIGGER;  // dummy to suppress unused var warning

            stan::math::initialize(TRIGGER, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(TRIGGER,DUMMY_VAR__);
            stan::math::assign(TRIGGER,get_base1(x,7,"x",1));
            fun_scalar_t__ Eps;
            (void) Eps;  // dummy to suppress unused var warning

            stan::math::initialize(Eps, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Eps,DUMMY_VAR__);
            stan::math::assign(Eps,get_base1(x,8,"x",1));
            fun_scalar_t__ FV_FX;
            (void) FV_FX;  // dummy to suppress unused var warning

            stan::math::initialize(FV_FX, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(FV_FX,DUMMY_VAR__);
            stan::math::assign(FV_FX,get_base1(x,9,"x",1));
            fun_scalar_t__ FV_FXA;
            (void) FV_FXA;  // dummy to suppress unused var warning

            stan::math::initialize(FV_FXA, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(FV_FXA,DUMMY_VAR__);
            stan::math::assign(FV_FXA,get_base1(x,10,"x",1));
            fun_scalar_t__ PROTHOMBINASE_PLATELETS;
            (void) PROTHOMBINASE_PLATELETS;  // dummy to suppress unused var warning

            stan::math::initialize(PROTHOMBINASE_PLATELETS, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(PROTHOMBINASE_PLATELETS,DUMMY_VAR__);
            stan::math::assign(PROTHOMBINASE_PLATELETS,get_base1(x,11,"x",1));
            fun_scalar_t__ TFPI;
            (void) TFPI;  // dummy to suppress unused var warning

            stan::math::initialize(TFPI, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(TFPI,DUMMY_VAR__);
            stan::math::assign(TFPI,get_base1(theta,47,"theta",1));
            fun_scalar_t__ FVIII;
            (void) FVIII;  // dummy to suppress unused var warning

            stan::math::initialize(FVIII, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(FVIII,DUMMY_VAR__);
            stan::math::assign(FVIII,get_base1(theta,48,"theta",1));
            fun_scalar_t__ FIX;
            (void) FIX;  // dummy to suppress unused var warning

            stan::math::initialize(FIX, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(FIX,DUMMY_VAR__);
            stan::math::assign(FIX,get_base1(theta,49,"theta",1));
            fun_scalar_t__ FVIII_control;
            (void) FVIII_control;  // dummy to suppress unused var warning

            stan::math::initialize(FVIII_control, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(FVIII_control,DUMMY_VAR__);
            stan::math::assign(FVIII_control,get_base1(theta,50,"theta",1));
            fun_scalar_t__ ALEPH;
            (void) ALEPH;  // dummy to suppress unused var warning

            stan::math::initialize(ALEPH, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ALEPH,DUMMY_VAR__);
            stan::math::assign(ALEPH,get_base1(theta,51,"theta",1));
            fun_scalar_t__ alpha_trigger_activation;
            (void) alpha_trigger_activation;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_trigger_activation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_trigger_activation,DUMMY_VAR__);
            stan::math::assign(alpha_trigger_activation,get_base1(theta,19,"theta",1));
            fun_scalar_t__ order_trigger_activation;
            (void) order_trigger_activation;  // dummy to suppress unused var warning

            stan::math::initialize(order_trigger_activation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_trigger_activation,DUMMY_VAR__);
            stan::math::assign(order_trigger_activation,get_base1(theta,20,"theta",1));
            fun_scalar_t__ alpha_trigger_inhibition_APC;
            (void) alpha_trigger_inhibition_APC;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_trigger_inhibition_APC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_trigger_inhibition_APC,DUMMY_VAR__);
            stan::math::assign(alpha_trigger_inhibition_APC,get_base1(theta,21,"theta",1));
            fun_scalar_t__ order_trigger_inhibition_APC;
            (void) order_trigger_inhibition_APC;  // dummy to suppress unused var warning

            stan::math::initialize(order_trigger_inhibition_APC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_trigger_inhibition_APC,DUMMY_VAR__);
            stan::math::assign(order_trigger_inhibition_APC,get_base1(theta,22,"theta",1));
            fun_scalar_t__ alpha_trigger_inhibition_TFPI;
            (void) alpha_trigger_inhibition_TFPI;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_trigger_inhibition_TFPI, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_trigger_inhibition_TFPI,DUMMY_VAR__);
            stan::math::assign(alpha_trigger_inhibition_TFPI,get_base1(theta,23,"theta",1));
            fun_scalar_t__ order_trigger_inhibition_TFPI;
            (void) order_trigger_inhibition_TFPI;  // dummy to suppress unused var warning

            stan::math::initialize(order_trigger_inhibition_TFPI, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_trigger_inhibition_TFPI,DUMMY_VAR__);
            stan::math::assign(order_trigger_inhibition_TFPI,get_base1(theta,24,"theta",1));
            fun_scalar_t__ alpha_amplification_FIIa;
            (void) alpha_amplification_FIIa;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_amplification_FIIa, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_amplification_FIIa,DUMMY_VAR__);
            stan::math::assign(alpha_amplification_FIIa,get_base1(theta,25,"theta",1));
            fun_scalar_t__ order_amplification_FIIa;
            (void) order_amplification_FIIa;  // dummy to suppress unused var warning

            stan::math::initialize(order_amplification_FIIa, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_amplification_FIIa,DUMMY_VAR__);
            stan::math::assign(order_amplification_FIIa,get_base1(theta,26,"theta",1));
            fun_scalar_t__ alpha_amplification_APC;
            (void) alpha_amplification_APC;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_amplification_APC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_amplification_APC,DUMMY_VAR__);
            stan::math::assign(alpha_amplification_APC,get_base1(theta,27,"theta",1));
            fun_scalar_t__ order_amplification_APC;
            (void) order_amplification_APC;  // dummy to suppress unused var warning

            stan::math::initialize(order_amplification_APC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_amplification_APC,DUMMY_VAR__);
            stan::math::assign(order_amplification_APC,get_base1(theta,28,"theta",1));
            fun_scalar_t__ alpha_amplification_TFPI;
            (void) alpha_amplification_TFPI;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_amplification_TFPI, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_amplification_TFPI,DUMMY_VAR__);
            stan::math::assign(alpha_amplification_TFPI,get_base1(theta,29,"theta",1));
            fun_scalar_t__ order_amplification_TFPI;
            (void) order_amplification_TFPI;  // dummy to suppress unused var warning

            stan::math::initialize(order_amplification_TFPI, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_amplification_TFPI,DUMMY_VAR__);
            stan::math::assign(order_amplification_TFPI,get_base1(theta,30,"theta",1));
            fun_scalar_t__ alpha_shutdown_APC;
            (void) alpha_shutdown_APC;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_shutdown_APC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_shutdown_APC,DUMMY_VAR__);
            stan::math::assign(alpha_shutdown_APC,get_base1(theta,31,"theta",1));
            fun_scalar_t__ order_shutdown_APC;
            (void) order_shutdown_APC;  // dummy to suppress unused var warning

            stan::math::initialize(order_shutdown_APC, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_shutdown_APC,DUMMY_VAR__);
            stan::math::assign(order_shutdown_APC,get_base1(theta,32,"theta",1));
            fun_scalar_t__ alpha_FV_activation;
            (void) alpha_FV_activation;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_FV_activation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_FV_activation,DUMMY_VAR__);
            stan::math::assign(alpha_FV_activation,get_base1(theta,33,"theta",1));
            fun_scalar_t__ order_FV_activation;
            (void) order_FV_activation;  // dummy to suppress unused var warning

            stan::math::initialize(order_FV_activation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_FV_activation,DUMMY_VAR__);
            stan::math::assign(order_FV_activation,get_base1(theta,34,"theta",1));
            fun_scalar_t__ alpha_FX_activation;
            (void) alpha_FX_activation;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_FX_activation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_FX_activation,DUMMY_VAR__);
            stan::math::assign(alpha_FX_activation,get_base1(theta,35,"theta",1));
            fun_scalar_t__ order_FX_activation;
            (void) order_FX_activation;  // dummy to suppress unused var warning

            stan::math::initialize(order_FX_activation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_FX_activation,DUMMY_VAR__);
            stan::math::assign(order_FX_activation,get_base1(theta,36,"theta",1));
            fun_scalar_t__ alpha_FX_inhibition;
            (void) alpha_FX_inhibition;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_FX_inhibition, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_FX_inhibition,DUMMY_VAR__);
            stan::math::assign(alpha_FX_inhibition,get_base1(theta,37,"theta",1));
            fun_scalar_t__ order_FX_inhibition;
            (void) order_FX_inhibition;  // dummy to suppress unused var warning

            stan::math::initialize(order_FX_inhibition, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(order_FX_inhibition,DUMMY_VAR__);
            stan::math::assign(order_FX_inhibition,get_base1(theta,38,"theta",1));
            fun_scalar_t__ kplatelts;
            (void) kplatelts;  // dummy to suppress unused var warning

            stan::math::initialize(kplatelts, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kplatelts,DUMMY_VAR__);
            stan::math::assign(kplatelts,get_base1(theta,39,"theta",1));
            fun_scalar_t__ platelet_pwr;
            (void) platelet_pwr;  // dummy to suppress unused var warning

            stan::math::initialize(platelet_pwr, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(platelet_pwr,DUMMY_VAR__);
            stan::math::assign(platelet_pwr,get_base1(theta,40,"theta",1));
            fun_scalar_t__ platelet_denom;
            (void) platelet_denom;  // dummy to suppress unused var warning

            stan::math::initialize(platelet_denom, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(platelet_denom,DUMMY_VAR__);
            stan::math::assign(platelet_denom,get_base1(theta,41,"theta",1));
            fun_scalar_t__ EpsMax0;
            (void) EpsMax0;  // dummy to suppress unused var warning

            stan::math::initialize(EpsMax0, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(EpsMax0,DUMMY_VAR__);
            stan::math::assign(EpsMax0,get_base1(theta,42,"theta",1));
            fun_scalar_t__ aida;
            (void) aida;  // dummy to suppress unused var warning

            stan::math::initialize(aida, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(aida,DUMMY_VAR__);
            stan::math::assign(aida,get_base1(theta,43,"theta",1));
            fun_scalar_t__ koffplatelets;
            (void) koffplatelets;  // dummy to suppress unused var warning

            stan::math::initialize(koffplatelets, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(koffplatelets,DUMMY_VAR__);
            stan::math::assign(koffplatelets,get_base1(theta,44,"theta",1));
            fun_scalar_t__ time_delay;
            (void) time_delay;  // dummy to suppress unused var warning

            stan::math::initialize(time_delay, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(time_delay,DUMMY_VAR__);
            stan::math::assign(time_delay,get_base1(theta,45,"theta",1));
            fun_scalar_t__ time_coeff;
            (void) time_coeff;  // dummy to suppress unused var warning

            stan::math::initialize(time_coeff, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(time_coeff,DUMMY_VAR__);
            stan::math::assign(time_coeff,get_base1(theta,46,"theta",1));
            fun_scalar_t__ k_trigger;
            (void) k_trigger;  // dummy to suppress unused var warning

            stan::math::initialize(k_trigger, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_trigger,DUMMY_VAR__);
            stan::math::assign(k_trigger,get_base1(theta,1,"theta",1));
            fun_scalar_t__ K_trigger;
            (void) K_trigger;  // dummy to suppress unused var warning

            stan::math::initialize(K_trigger, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K_trigger,DUMMY_VAR__);
            stan::math::assign(K_trigger,get_base1(theta,2,"theta",1));
            fun_scalar_t__ k_amplification;
            (void) k_amplification;  // dummy to suppress unused var warning

            stan::math::initialize(k_amplification, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_amplification,DUMMY_VAR__);
            stan::math::assign(k_amplification,get_base1(theta,3,"theta",1));
            fun_scalar_t__ K_FII_amplification;
            (void) K_FII_amplification;  // dummy to suppress unused var warning

            stan::math::initialize(K_FII_amplification, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K_FII_amplification,DUMMY_VAR__);
            stan::math::assign(K_FII_amplification,get_base1(theta,4,"theta",1));
            fun_scalar_t__ k_APC_formation;
            (void) k_APC_formation;  // dummy to suppress unused var warning

            stan::math::initialize(k_APC_formation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_APC_formation,DUMMY_VAR__);
            stan::math::assign(k_APC_formation,get_base1(theta,5,"theta",1));
            fun_scalar_t__ K_PC_formation;
            (void) K_PC_formation;  // dummy to suppress unused var warning

            stan::math::initialize(K_PC_formation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K_PC_formation,DUMMY_VAR__);
            stan::math::assign(K_PC_formation,get_base1(theta,6,"theta",1));
            fun_scalar_t__ k_inhibition;
            (void) k_inhibition;  // dummy to suppress unused var warning

            stan::math::initialize(k_inhibition, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_inhibition,DUMMY_VAR__);
            stan::math::assign(k_inhibition,get_base1(theta,7,"theta",1));
            fun_scalar_t__ K_FIIa_inhibition;
            (void) K_FIIa_inhibition;  // dummy to suppress unused var warning

            stan::math::initialize(K_FIIa_inhibition, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K_FIIa_inhibition,DUMMY_VAR__);
            stan::math::assign(K_FIIa_inhibition,get_base1(theta,8,"theta",1));
            fun_scalar_t__ k_inhibition_ATIII;
            (void) k_inhibition_ATIII;  // dummy to suppress unused var warning

            stan::math::initialize(k_inhibition_ATIII, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_inhibition_ATIII,DUMMY_VAR__);
            stan::math::assign(k_inhibition_ATIII,get_base1(theta,9,"theta",1));
            fun_scalar_t__ k_FV_X_activation;
            (void) k_FV_X_activation;  // dummy to suppress unused var warning

            stan::math::initialize(k_FV_X_activation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_FV_X_activation,DUMMY_VAR__);
            stan::math::assign(k_FV_X_activation,get_base1(theta,10,"theta",1));
            fun_scalar_t__ K_FV_X_actiation;
            (void) K_FV_X_actiation;  // dummy to suppress unused var warning

            stan::math::initialize(K_FV_X_actiation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K_FV_X_actiation,DUMMY_VAR__);
            stan::math::assign(K_FV_X_actiation,get_base1(theta,11,"theta",1));
            fun_scalar_t__ k_complex;
            (void) k_complex;  // dummy to suppress unused var warning

            stan::math::initialize(k_complex, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_complex,DUMMY_VAR__);
            stan::math::assign(k_complex,get_base1(theta,14,"theta",1));
            fun_scalar_t__ k_amp_prothombinase;
            (void) k_amp_prothombinase;  // dummy to suppress unused var warning

            stan::math::initialize(k_amp_prothombinase, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_amp_prothombinase,DUMMY_VAR__);
            stan::math::assign(k_amp_prothombinase,get_base1(theta,15,"theta",1));
            fun_scalar_t__ K_FII_amp_prothombinase;
            (void) K_FII_amp_prothombinase;  // dummy to suppress unused var warning

            stan::math::initialize(K_FII_amp_prothombinase, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K_FII_amp_prothombinase,DUMMY_VAR__);
            stan::math::assign(K_FII_amp_prothombinase,get_base1(theta,16,"theta",1));
            fun_scalar_t__ k_amp_active_factors;
            (void) k_amp_active_factors;  // dummy to suppress unused var warning

            stan::math::initialize(k_amp_active_factors, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k_amp_active_factors,DUMMY_VAR__);
            stan::math::assign(k_amp_active_factors,get_base1(theta,17,"theta",1));
            fun_scalar_t__ K_amp_active_factors;
            (void) K_amp_active_factors;  // dummy to suppress unused var warning

            stan::math::initialize(K_amp_active_factors, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K_amp_active_factors,DUMMY_VAR__);
            stan::math::assign(K_amp_active_factors,get_base1(theta,18,"theta",1));
            fun_scalar_t__ local_aleph;
            (void) local_aleph;  // dummy to suppress unused var warning

            stan::math::initialize(local_aleph, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(local_aleph,DUMMY_VAR__);
            stan::math::assign(local_aleph,ALEPH);
            fun_scalar_t__ faleph;
            (void) faleph;  // dummy to suppress unused var warning

            stan::math::initialize(faleph, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(faleph,DUMMY_VAR__);
            fun_scalar_t__ EpsMax;
            (void) EpsMax;  // dummy to suppress unused var warning

            stan::math::initialize(EpsMax, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(EpsMax,DUMMY_VAR__);
            fun_scalar_t__ initiation_trigger_term;
            (void) initiation_trigger_term;  // dummy to suppress unused var warning

            stan::math::initialize(initiation_trigger_term, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(initiation_trigger_term,DUMMY_VAR__);
            fun_scalar_t__ initiation_TFPI_term;
            (void) initiation_TFPI_term;  // dummy to suppress unused var warning

            stan::math::initialize(initiation_TFPI_term, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(initiation_TFPI_term,DUMMY_VAR__);
            fun_scalar_t__ activation_term;
            (void) activation_term;  // dummy to suppress unused var warning

            stan::math::initialize(activation_term, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(activation_term,DUMMY_VAR__);
            fun_scalar_t__ inhibition_term;
            (void) inhibition_term;  // dummy to suppress unused var warning

            stan::math::initialize(inhibition_term, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(inhibition_term,DUMMY_VAR__);
            fun_scalar_t__ inhibition_term_TFPI;
            (void) inhibition_term_TFPI;  // dummy to suppress unused var warning

            stan::math::initialize(inhibition_term_TFPI, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(inhibition_term_TFPI,DUMMY_VAR__);
            fun_scalar_t__ shutdown_term;
            (void) shutdown_term;  // dummy to suppress unused var warning

            stan::math::initialize(shutdown_term, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(shutdown_term,DUMMY_VAR__);
            fun_scalar_t__ activation_FV_by_thrombin;
            (void) activation_FV_by_thrombin;  // dummy to suppress unused var warning

            stan::math::initialize(activation_FV_by_thrombin, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(activation_FV_by_thrombin,DUMMY_VAR__);
            fun_scalar_t__ activation_FX_by_trigger;
            (void) activation_FX_by_trigger;  // dummy to suppress unused var warning

            stan::math::initialize(activation_FX_by_trigger, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(activation_FX_by_trigger,DUMMY_VAR__);
            fun_scalar_t__ inhibition_of_FX_by_ATIII;
            (void) inhibition_of_FX_by_ATIII;  // dummy to suppress unused var warning

            stan::math::initialize(inhibition_of_FX_by_ATIII, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(inhibition_of_FX_by_ATIII,DUMMY_VAR__);
            validate_non_negative_index("term1", "2", 2);
            vector<fun_scalar_t__> term1(2);
            stan::math::initialize(term1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(term1,DUMMY_VAR__);
            validate_non_negative_index("term2", "2", 2);
            vector<fun_scalar_t__> term2(2);
            stan::math::initialize(term2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(term2,DUMMY_VAR__);
            fun_scalar_t__ tau;
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);
            fun_scalar_t__ time_scale;
            (void) time_scale;  // dummy to suppress unused var warning

            stan::math::initialize(time_scale, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(time_scale,DUMMY_VAR__);


            current_statement_begin__ = 101;
            if (as_bool(logical_gt(FIIa,local_aleph))) {

                current_statement_begin__ = 102;
                stan::math::assign(local_aleph, FIIa);
            }
            current_statement_begin__ = 104;
            stan::math::assign(faleph, (pow(local_aleph,platelet_pwr) / (pow(local_aleph,platelet_pwr) + pow(platelet_denom,platelet_pwr))));
            current_statement_begin__ = 105;
            stan::math::assign(EpsMax, (EpsMax0 + ((1 + EpsMax0) * faleph)));
            current_statement_begin__ = 107;
            stan::math::assign(initiation_trigger_term, (pow((alpha_trigger_activation * TRIGGER),order_trigger_activation) / (1 + pow((alpha_trigger_activation * TRIGGER),order_trigger_activation))));
            current_statement_begin__ = 108;
            stan::math::assign(initiation_TFPI_term, (1 - (pow((alpha_trigger_inhibition_TFPI * TFPI),order_trigger_inhibition_TFPI) / (1 + pow((alpha_trigger_inhibition_TFPI * TFPI),order_trigger_inhibition_TFPI)))));
            current_statement_begin__ = 110;
            stan::math::assign(activation_term, (pow((alpha_amplification_FIIa * FIIa),order_amplification_FIIa) / (1 + pow((alpha_amplification_FIIa * FIIa),order_amplification_FIIa))));
            current_statement_begin__ = 111;
            stan::math::assign(inhibition_term, (pow((alpha_amplification_APC * APC),order_amplification_APC) / (1 + pow((alpha_amplification_APC * APC),order_amplification_APC))));
            current_statement_begin__ = 112;
            stan::math::assign(inhibition_term_TFPI, (pow((alpha_amplification_TFPI * TFPI),order_amplification_TFPI) / (1 + pow((alpha_amplification_TFPI * TFPI),order_amplification_TFPI))));
            current_statement_begin__ = 113;
            stan::math::assign(shutdown_term, (pow((alpha_shutdown_APC * FIIa),order_shutdown_APC) / (1 + pow((alpha_shutdown_APC * FIIa),order_shutdown_APC))));
            current_statement_begin__ = 114;
            stan::math::assign(activation_FV_by_thrombin, (pow((alpha_FV_activation * FIIa),order_FV_activation) / (1 + pow((alpha_FV_activation * FIIa),order_FV_activation))));
            current_statement_begin__ = 115;
            stan::math::assign(activation_FX_by_trigger, (pow((alpha_FX_activation * TRIGGER),order_FX_activation) / (1 + pow((alpha_FX_activation * TRIGGER),order_FX_activation))));
            current_statement_begin__ = 116;
            stan::math::assign(inhibition_of_FX_by_ATIII, (1 - (pow((alpha_FX_inhibition * ATIII),order_FX_inhibition) / (1 + pow((alpha_FX_inhibition * ATIII),order_FX_inhibition)))));
            current_statement_begin__ = 117;
            stan::math::assign(get_base1_lhs(term1,1,"term1",1), initiation_trigger_term);
            current_statement_begin__ = 118;
            stan::math::assign(get_base1_lhs(term1,2,"term1",1), initiation_TFPI_term);
            current_statement_begin__ = 119;
            stan::math::assign(get_base1_lhs(term2,1,"term2",1), inhibition_term);
            current_statement_begin__ = 120;
            stan::math::assign(get_base1_lhs(term2,2,"term2",1), inhibition_term_TFPI);
            current_statement_begin__ = 121;
            stan::math::assign(get_base1_lhs(control_vector,1,"control_vector",1), min(term1));
            current_statement_begin__ = 122;
            stan::math::assign(get_base1_lhs(control_vector,2,"control_vector",1), min(term2));
            current_statement_begin__ = 123;
            stan::math::assign(get_base1_lhs(control_vector,3,"control_vector",1), shutdown_term);
            current_statement_begin__ = 124;
            stan::math::assign(get_base1_lhs(control_vector,4,"control_vector",1), 1);
            current_statement_begin__ = 125;
            stan::math::assign(get_base1_lhs(control_vector,5,"control_vector",1), 1);
            current_statement_begin__ = 126;
            stan::math::assign(get_base1_lhs(control_vector,6,"control_vector",1), FVIII_control);
            current_statement_begin__ = 127;
            stan::math::assign(get_base1_lhs(control_vector,7,"control_vector",1), (1 - max(term2)));
            current_statement_begin__ = 129;
            stan::math::assign(get_base1_lhs(rate_vector,1,"rate_vector",1), ((k_trigger * TRIGGER) * (FV_FX / (K_trigger + FV_FX))));
            current_statement_begin__ = 130;
            stan::math::assign(get_base1_lhs(rate_vector,2,"rate_vector",1), ((k_amplification * FIIa) * (FII / (K_FII_amplification + FII))));
            current_statement_begin__ = 131;
            stan::math::assign(get_base1_lhs(rate_vector,3,"rate_vector",1), ((k_APC_formation * TM) * (PC / (K_PC_formation + PC))));
            current_statement_begin__ = 132;
            stan::math::assign(get_base1_lhs(rate_vector,4,"rate_vector",1), ((k_inhibition_ATIII * ATIII) * pow(FIIa,1.26)));
            current_statement_begin__ = 133;
            stan::math::assign(get_base1_lhs(rate_vector,5,"rate_vector",1), (((k_complex * FV_FXA) * aida) / Eps));
            current_statement_begin__ = 134;
            stan::math::assign(get_base1_lhs(rate_vector,6,"rate_vector",1), (((k_amp_prothombinase * PROTHOMBINASE_PLATELETS) * FII) / (K_FII_amp_prothombinase + FII)));
            current_statement_begin__ = 135;
            stan::math::assign(get_base1_lhs(rate_vector,7,"rate_vector",1), (((k_amp_active_factors * FV_FXA) * FII) / (K_amp_active_factors + FII)));
            current_statement_begin__ = 137;
            stan::math::assign(modified_rate_vector, elt_multiply(rate_vector,control_vector));
            current_statement_begin__ = 139;
            stan::math::assign(get_base1_lhs(dxdt_total,1,"dxdt_total",1), (((-(1.0) * get_base1(modified_rate_vector,2,"modified_rate_vector",1)) - get_base1(modified_rate_vector,7,"modified_rate_vector",1)) - get_base1(modified_rate_vector,6,"modified_rate_vector",1)));
            current_statement_begin__ = 140;
            stan::math::assign(get_base1_lhs(dxdt_total,2,"dxdt_total",1), (((get_base1(modified_rate_vector,2,"modified_rate_vector",1) - get_base1(modified_rate_vector,4,"modified_rate_vector",1)) + get_base1(modified_rate_vector,7,"modified_rate_vector",1)) + get_base1(modified_rate_vector,6,"modified_rate_vector",1)));
            current_statement_begin__ = 141;
            stan::math::assign(get_base1_lhs(dxdt_total,3,"dxdt_total",1), (-(1) * get_base1(modified_rate_vector,3,"modified_rate_vector",1)));
            current_statement_begin__ = 142;
            stan::math::assign(get_base1_lhs(dxdt_total,4,"dxdt_total",1), (1 * get_base1(modified_rate_vector,3,"modified_rate_vector",1)));
            current_statement_begin__ = 143;
            stan::math::assign(get_base1_lhs(dxdt_total,5,"dxdt_total",1), (((-(1) * k_inhibition_ATIII) * ATIII) * pow(FIIa,1.26)));
            current_statement_begin__ = 144;
            stan::math::assign(get_base1_lhs(dxdt_total,6,"dxdt_total",1), 0.0);
            current_statement_begin__ = 145;
            stan::math::assign(get_base1_lhs(dxdt_total,7,"dxdt_total",1), (-(0.0) * TRIGGER));
            current_statement_begin__ = 146;
            stan::math::assign(get_base1_lhs(dxdt_total,8,"dxdt_total",1), ((kplatelts * (EpsMax - Eps)) - (koffplatelets * Eps)));
            current_statement_begin__ = 147;
            stan::math::assign(get_base1_lhs(dxdt_total,9,"dxdt_total",1), (-(1) * get_base1(modified_rate_vector,1,"modified_rate_vector",1)));
            current_statement_begin__ = 148;
            stan::math::assign(get_base1_lhs(dxdt_total,10,"dxdt_total",1), (get_base1(modified_rate_vector,1,"modified_rate_vector",1) - get_base1(modified_rate_vector,5,"modified_rate_vector",1)));
            current_statement_begin__ = 149;
            stan::math::assign(get_base1_lhs(dxdt_total,11,"dxdt_total",1), get_base1(modified_rate_vector,5,"modified_rate_vector",1));
            current_statement_begin__ = 151;
            stan::math::assign(tau, (time_coeff * (1 - (FIIa / local_aleph))));
            current_statement_begin__ = 152;
            stan::math::assign(time_scale, (1 - (1 * exp((-(tau) * (t - time_delay))))));
            current_statement_begin__ = 153;
            if (as_bool(logical_lt(t,time_delay))) {

                current_statement_begin__ = 154;
                stan::math::assign(time_scale, 0.0);
            }
            current_statement_begin__ = 156;
            for (int j = 1; j <= 11; ++j) {

                current_statement_begin__ = 157;
                stan::math::assign(get_base1_lhs(dxdt,j,"dxdt",1), (get_base1(dxdt_total,j,"dxdt_total",1) * time_scale));
            }
            current_statement_begin__ = 159;
            return stan::math::promote_scalar<fun_return_scalar_t__>(dxdt);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct Balances_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
    operator()(const T0__& t,
             const std::vector<T1__>& x,
             const std::vector<T2__>& theta,
             const std::vector<T3__>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__) const {
        return Balances(t, x, theta, x_r, x_i, pstream__);
    }
};

class odePlatelets_model : public prob_grad {
private:
    int T;
    int M;
    double t0;
    vector<double> x0;
    vector<double> ts;
    vector<vector<double> > x;
    vector<double> theta;
    vector<double> x_r;
    vector<int> x_i;
public:
    odePlatelets_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        typedef boost::ecuyer1988 rng_t;
        rng_t base_rng(0);  // 0 seed default
        ctor_body(context__, base_rng, pstream__);
    }

    template <class RNG>
    odePlatelets_model(stan::io::var_context& context__,
        RNG& base_rng__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, base_rng__, pstream__);
    }

    template <class RNG>
    void ctor_body(stan::io::var_context& context__,
                   RNG& base_rng__,
                   std::ostream* pstream__) {
        current_statement_begin__ = -1;

        static const char* function__ = "odePlatelets_model_namespace::odePlatelets_model";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "T", "int", context__.to_vec());
        T = int(0);
        vals_i__ = context__.vals_i("T");
        pos__ = 0;
        T = vals_i__[pos__++];
        context__.validate_dims("data initialization", "M", "int", context__.to_vec());
        M = int(0);
        vals_i__ = context__.vals_i("M");
        pos__ = 0;
        M = vals_i__[pos__++];
        context__.validate_dims("data initialization", "t0", "double", context__.to_vec());
        t0 = double(0);
        vals_r__ = context__.vals_r("t0");
        pos__ = 0;
        t0 = vals_r__[pos__++];
        validate_non_negative_index("x0", "11", 11);
        context__.validate_dims("data initialization", "x0", "double", context__.to_vec(11));
        validate_non_negative_index("x0", "11", 11);
        x0 = std::vector<double>(11,double(0));
        vals_r__ = context__.vals_r("x0");
        pos__ = 0;
        size_t x0_limit_0__ = 11;
        for (size_t i_0__ = 0; i_0__ < x0_limit_0__; ++i_0__) {
            x0[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("ts", "T", T);
        context__.validate_dims("data initialization", "ts", "double", context__.to_vec(T));
        validate_non_negative_index("ts", "T", T);
        ts = std::vector<double>(T,double(0));
        vals_r__ = context__.vals_r("ts");
        pos__ = 0;
        size_t ts_limit_0__ = T;
        for (size_t i_0__ = 0; i_0__ < ts_limit_0__; ++i_0__) {
            ts[i_0__] = vals_r__[pos__++];
        }
        validate_non_negative_index("x", "T", T);
        validate_non_negative_index("x", "M", M);
        context__.validate_dims("data initialization", "x", "double", context__.to_vec(T,M));
        validate_non_negative_index("x", "T", T);
        validate_non_negative_index("x", "M", M);
        x = std::vector<std::vector<double> >(T,std::vector<double>(M,double(0)));
        vals_r__ = context__.vals_r("x");
        pos__ = 0;
        size_t x_limit_1__ = M;
        for (size_t i_1__ = 0; i_1__ < x_limit_1__; ++i_1__) {
            size_t x_limit_0__ = T;
            for (size_t i_0__ = 0; i_0__ < x_limit_0__; ++i_0__) {
                x[i_0__][i_1__] = vals_r__[pos__++];
            }
        }
        validate_non_negative_index("theta", "51", 51);
        context__.validate_dims("data initialization", "theta", "double", context__.to_vec(51));
        validate_non_negative_index("theta", "51", 51);
        theta = std::vector<double>(51,double(0));
        vals_r__ = context__.vals_r("theta");
        pos__ = 0;
        size_t theta_limit_0__ = 51;
        for (size_t i_0__ = 0; i_0__ < theta_limit_0__; ++i_0__) {
            theta[i_0__] = vals_r__[pos__++];
        }

        // validate, data variables
        check_greater_or_equal(function__,"T",T,1);
        check_greater_or_equal(function__,"M",M,1);
        // initialize data variables
        validate_non_negative_index("x_r", "0", 0);
        x_r = std::vector<double>(0,double(0));
        stan::math::fill(x_r,DUMMY_VAR__);
        validate_non_negative_index("x_i", "0", 0);
        x_i = std::vector<int>(0,int(0));
        stan::math::fill(x_i, std::numeric_limits<int>::min());

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
    }

    ~odePlatelets_model() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);


        // transformed parameters


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning

        // model body
        try {

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("x_hat");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(T);
        dims__.push_back(11);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "odePlatelets_model_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning



        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters

        // write transformed parameters

        if (!include_gqs__) return;
        // declare and define generated quantities
        validate_non_negative_index("x_hat", "T", T);
        validate_non_negative_index("x_hat", "11", 11);
        vector<vector<double> > x_hat(T, (vector<double>(11, 0.0)));
        stan::math::initialize(x_hat, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(x_hat,DUMMY_VAR__);


        try {
            current_statement_begin__ = 184;
            stan::math::assign(x_hat, integrate_ode_rk45(Balances_functor__(), x0, t0, ts, theta, x_r, x_i, pstream__));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
        for (int k_1__ = 0; k_1__ < 11; ++k_1__) {
            for (int k_0__ = 0; k_0__ < T; ++k_0__) {
                vars__.push_back(x_hat[k_0__][k_1__]);
            }
        }

    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "odePlatelets_model";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
        for (int k_1__ = 1; k_1__ <= 11; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "x_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
        for (int k_1__ = 1; k_1__ <= 11; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "x_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}

typedef odePlatelets_model_namespace::odePlatelets_model stan_model;

